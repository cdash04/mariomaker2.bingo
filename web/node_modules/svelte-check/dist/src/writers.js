"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MachineFriendlyWriter = exports.HumanFriendlyWriter = exports.DEFAULT_FILTER = void 0;
const chalk = require("chalk");
const path_1 = require("path");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const svelte_language_server_1 = require("svelte-language-server");
exports.DEFAULT_FILTER = () => true;
class HumanFriendlyWriter {
    constructor(stream, isVerbose = true, diagnosticFilter = exports.DEFAULT_FILTER) {
        this.stream = stream;
        this.isVerbose = isVerbose;
        this.diagnosticFilter = diagnosticFilter;
    }
    start(workspaceDir) {
        if (this.isVerbose) {
            this.stream.write('\n');
            this.stream.write(`Loading svelte-check in workspace: ${workspaceDir}`);
            this.stream.write('\n');
            this.stream.write('Getting Svelte diagnostics...\n');
            this.stream.write('====================================\n');
            this.stream.write('\n');
        }
    }
    file(diagnostics, workspaceDir, filename, text) {
        diagnostics.filter(this.diagnosticFilter).forEach((diagnostic) => {
            const source = diagnostic.source ? `(${diagnostic.source})` : '';
            // Display location in a format that IDEs will turn into file links
            const { line, character } = diagnostic.range.start;
            // eslint-disable-next-line max-len
            this.stream.write(`${workspaceDir}${path_1.sep}${chalk.green(filename)}:${line + 1}:${character + 1}\n`);
            // Show some context around diagnostic range
            const codePrevLine = this.getLine(diagnostic.range.start.line - 1, text);
            const codeLine = this.getCodeLine(diagnostic, text);
            const codeNextLine = this.getLine(diagnostic.range.end.line + 1, text);
            const code = codePrevLine + codeLine + codeNextLine;
            let msg;
            if (this.isVerbose) {
                msg = `${diagnostic.message} ${source}\n${chalk.cyan(code)}`;
            }
            else {
                msg = `${diagnostic.message} ${source}`;
            }
            if (diagnostic.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error) {
                this.stream.write(`${chalk.red('Error')}: ${msg}\n`);
            }
            else if (diagnostic.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Warning) {
                this.stream.write(`${chalk.yellow('Warn')}: ${msg}\n`);
            }
            else {
                this.stream.write(`${chalk.gray('Hint')}: ${msg}\n`);
            }
            this.stream.write('\n');
        });
    }
    getCodeLine(diagnostic, text) {
        const startOffset = svelte_language_server_1.offsetAt(diagnostic.range.start, text);
        const endOffset = svelte_language_server_1.offsetAt(diagnostic.range.end, text);
        const codePrev = text.substring(svelte_language_server_1.offsetAt({ line: diagnostic.range.start.line, character: 0 }, text), startOffset);
        const codeHighlight = chalk.magenta(text.substring(startOffset, endOffset));
        const codePost = text.substring(endOffset, svelte_language_server_1.offsetAt({ line: diagnostic.range.end.line, character: Number.MAX_SAFE_INTEGER }, text));
        return codePrev + codeHighlight + codePost;
    }
    getLine(line, text) {
        return text.substring(svelte_language_server_1.offsetAt({ line, character: 0 }, text), svelte_language_server_1.offsetAt({ line, character: Number.MAX_SAFE_INTEGER }, text));
    }
    completion(_f, errorCount, warningCount, hintCount) {
        this.stream.write('====================================\n');
        const message = [
            'svelte-check found ',
            `${errorCount} ${errorCount === 1 ? 'error' : 'errors'}, `,
            `${warningCount} ${warningCount === 1 ? 'warning' : 'warnings'} and `,
            `${hintCount} ${hintCount === 1 ? 'hint' : 'hints'}\n`,
        ].join('');
        if (errorCount !== 0) {
            this.stream.write(chalk.red(message));
        }
        else if (warningCount !== 0) {
            this.stream.write(chalk.yellow(message));
        }
        else if (hintCount !== 0) {
            this.stream.write(chalk.grey(message));
        }
        else {
            this.stream.write(chalk.green(message));
        }
    }
    failure(err) {
        this.stream.write(`${err}\n`);
    }
}
exports.HumanFriendlyWriter = HumanFriendlyWriter;
class MachineFriendlyWriter {
    constructor(stream, diagnosticFilter = exports.DEFAULT_FILTER) {
        this.stream = stream;
        this.diagnosticFilter = diagnosticFilter;
    }
    log(msg) {
        this.stream.write(`${new Date().getTime()} ${msg}\n`);
    }
    start(workspaceDir) {
        this.log(`START ${JSON.stringify(workspaceDir)}`);
    }
    file(diagnostics, workspaceDir, filename, _text) {
        diagnostics.filter(this.diagnosticFilter).forEach((d) => {
            const { message, severity, range } = d;
            const type = severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error
                ? 'ERROR'
                : severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Warning
                    ? 'WARNING'
                    : null;
            if (type) {
                const { line, character } = range.start;
                const fn = JSON.stringify(filename);
                const msg = JSON.stringify(message);
                this.log(`${type} ${fn} ${line + 1}:${character + 1} ${msg}`);
            }
        });
    }
    completion(fileCount, errorCount, warningCount, hintCount) {
        this.log([
            'COMPLETED',
            `${fileCount} FILES`,
            `${errorCount} ERRORS`,
            `${warningCount} WARNINGS`,
            `${hintCount} HINTS`,
        ].join(' '));
    }
    failure(err) {
        this.log(`FAILURE ${JSON.stringify(err.message)}`);
    }
}
exports.MachineFriendlyWriter = MachineFriendlyWriter;
