"use strict";
/**
 * This code's groundwork is taken from https://github.com/vuejs/vetur/tree/master/vti
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const glob = require("glob");
const argv = require("minimist");
const path = require("path");
const svelte_language_server_1 = require("svelte-language-server");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const writers_1 = require("./writers");
const chokidar_1 = require("chokidar");
const outputFormats = ['human', 'human-verbose', 'machine'];
function openAllDocuments(workspaceUri, filePathsToIgnore, svelteCheck) {
    const files = glob.sync('**/*.svelte', {
        cwd: workspaceUri.fsPath,
        ignore: ['node_modules/**'].concat(filePathsToIgnore.map((ignore) => `${ignore}/**`)),
    });
    const absFilePaths = files.map((f) => path.resolve(workspaceUri.fsPath, f));
    for (const absFilePath of absFilePaths) {
        const text = fs.readFileSync(absFilePath, 'utf-8');
        svelteCheck.upsertDocument({
            uri: vscode_uri_1.URI.file(absFilePath).toString(),
            text,
        });
    }
}
async function getDiagnostics(workspaceUri, writer, svelteCheck) {
    writer.start(workspaceUri.fsPath);
    try {
        const diagnostics = await svelteCheck.getDiagnostics();
        const result = {
            fileCount: diagnostics.length,
            errorCount: 0,
            warningCount: 0,
            hintCount: 0,
        };
        for (const diagnostic of diagnostics) {
            writer.file(diagnostic.diagnostics, workspaceUri.fsPath, path.relative(workspaceUri.fsPath, diagnostic.filePath), diagnostic.text);
            diagnostic.diagnostics.forEach((d) => {
                if (d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error) {
                    result.errorCount += 1;
                }
                else if (d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Warning) {
                    result.warningCount += 1;
                }
                else if (d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Hint) {
                    result.hintCount += 1;
                }
            });
        }
        writer.completion(result.fileCount, result.errorCount, result.warningCount, result.hintCount);
        return result;
    }
    catch (err) {
        writer.failure(err);
        return null;
    }
}
class DiagnosticsWatcher {
    constructor(workspaceUri, svelteCheck, writer, filePathsToIgnore) {
        this.workspaceUri = workspaceUri;
        this.svelteCheck = svelteCheck;
        this.writer = writer;
        chokidar_1.watch(`${workspaceUri.fsPath}/**/*.svelte`, {
            ignored: ['node_modules']
                .concat(filePathsToIgnore)
                .map((ignore) => path.join(workspaceUri.fsPath, ignore)),
        })
            .on('add', (path) => this.updateDocument(path))
            .on('unlink', (path) => this.removeDocument(path))
            .on('change', (path) => this.updateDocument(path));
    }
    updateDocument(path) {
        const text = fs.readFileSync(path, 'utf-8');
        this.svelteCheck.upsertDocument({ text, uri: vscode_uri_1.URI.file(path).toString() });
        this.scheduleDiagnostics();
    }
    removeDocument(path) {
        this.svelteCheck.removeDocument(vscode_uri_1.URI.file(path).toString());
        this.scheduleDiagnostics();
    }
    scheduleDiagnostics() {
        clearTimeout(this.updateDiagnostics);
        this.updateDiagnostics = setTimeout(() => getDiagnostics(this.workspaceUri, this.writer, this.svelteCheck), 1000);
    }
}
function createFilter(myArgs) {
    switch (myArgs['threshold']) {
        case 'error':
            return (d) => d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error;
        case 'warning':
            return (d) => d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error
                || d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Warning;
        default:
            return writers_1.DEFAULT_FILTER;
    }
}
function instantiateWriter(myArgs) {
    const outputFormat = outputFormats.includes(myArgs['output'])
        ? myArgs['output']
        : 'human-verbose';
    const filter = createFilter(myArgs);
    if (outputFormat === 'human-verbose' || outputFormat === 'human') {
        return new writers_1.HumanFriendlyWriter(process.stdout, outputFormat === 'human-verbose', filter);
    }
    else {
        return new writers_1.MachineFriendlyWriter(process.stdout, filter);
    }
}
function getOptions(myArgs) {
    var _a, _b;
    return {
        compilerWarnings: stringToObj(myArgs['compiler-warnings']),
        diagnosticSources: ((_b = (_a = myArgs['diagnostic-sources']) === null || _a === void 0 ? void 0 : _a.split(',')) === null || _b === void 0 ? void 0 : _b.map((s) => s.trim())),
    };
    function stringToObj(str = '') {
        return str
            .split(',')
            .map((s) => s.trim())
            .filter((s) => !!s)
            .reduce((settings, setting) => {
            const [name, val] = setting.split(':');
            if (val === 'error' || val === 'ignore') {
                settings[name] = val;
            }
            return settings;
        }, {});
    }
}
(async () => {
    var _a;
    const myArgs = argv(process.argv.slice(1));
    let workspaceUri;
    let workspacePath = myArgs['workspace'];
    if (workspacePath) {
        if (!path.isAbsolute(workspacePath)) {
            workspacePath = path.resolve(process.cwd(), workspacePath);
        }
        workspaceUri = vscode_uri_1.URI.file(workspacePath);
    }
    else {
        workspaceUri = vscode_uri_1.URI.file(process.cwd());
    }
    const writer = instantiateWriter(myArgs);
    const svelteCheck = new svelte_language_server_1.SvelteCheck(workspaceUri.fsPath, getOptions(myArgs));
    const filePathsToIgnore = ((_a = myArgs['ignore']) === null || _a === void 0 ? void 0 : _a.split(',')) || [];
    if (myArgs['watch']) {
        new DiagnosticsWatcher(workspaceUri, svelteCheck, writer, filePathsToIgnore);
    }
    else {
        openAllDocuments(workspaceUri, filePathsToIgnore, svelteCheck);
        const result = await getDiagnostics(workspaceUri, writer, svelteCheck);
        if (result &&
            result.errorCount === 0 &&
            (!myArgs['fail-on-warnings'] || result.warningCount === 0) &&
            (!myArgs['fail-on-hints'] || result.hintCount === 0)) {
            process.exit(0);
        }
        else {
            process.exit(1);
        }
    }
})().catch((_err) => {
    console.error(_err);
    console.error('svelte-check failed');
});
