"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticsProviderImpl = void 0;
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../../lib/documents");
const utils_1 = require("../utils");
class DiagnosticsProviderImpl {
    constructor(lsAndTsDocResolver) {
        this.lsAndTsDocResolver = lsAndTsDocResolver;
    }
    async getDiagnostics(document) {
        const { lang, tsDoc } = this.getLSAndTSDoc(document);
        const isTypescript = tsDoc.scriptKind === typescript_1.default.ScriptKind.TSX;
        // Document preprocessing failed, show parser error instead
        if (tsDoc.parserError) {
            return [
                {
                    range: tsDoc.parserError.range,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                    source: isTypescript ? 'ts' : 'js',
                    message: tsDoc.parserError.message,
                    code: tsDoc.parserError.code,
                },
            ];
        }
        const diagnostics = [
            ...lang.getSyntacticDiagnostics(tsDoc.filePath),
            ...lang.getSuggestionDiagnostics(tsDoc.filePath),
            ...lang.getSemanticDiagnostics(tsDoc.filePath),
        ];
        const fragment = await tsDoc.getFragment();
        return diagnostics
            .map((diagnostic) => ({
            range: utils_1.convertRange(tsDoc, diagnostic),
            severity: utils_1.mapSeverity(diagnostic.category),
            source: isTypescript ? 'ts' : 'js',
            message: typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n'),
            code: diagnostic.code,
            tags: this.getDiagnosticTag(diagnostic)
        }))
            .map((diagnostic) => documents_1.mapObjWithRangeToOriginal(fragment, diagnostic))
            .filter(hasNoNegativeLines)
            .filter(isNoFalsePositive(document.getText(), tsDoc))
            .map(enhanceIfNecessary);
    }
    getDiagnosticTag(diagnostic) {
        const tags = [];
        if (diagnostic.reportsUnnecessary) {
            tags.push(vscode_languageserver_1.DiagnosticTag.Unnecessary);
        }
        if (diagnostic.reportsDeprecated) {
            tags.push(vscode_languageserver_1.DiagnosticTag.Deprecated);
        }
        return tags;
    }
    getLSAndTSDoc(document) {
        return this.lsAndTsDocResolver.getLSAndTSDoc(document);
    }
}
exports.DiagnosticsProviderImpl = DiagnosticsProviderImpl;
/**
 * In some rare cases mapping of diagnostics does not work and produces negative lines.
 * We filter out these diagnostics with negative lines because else the LSP
 * apparently has a hickup and does not show any diagnostics at all.
 */
function hasNoNegativeLines(diagnostic) {
    return diagnostic.range.start.line >= 0 && diagnostic.range.end.line >= 0;
}
function isNoFalsePositive(text, tsDoc) {
    return (diagnostic) => {
        return (isNoJsxCannotHaveMultipleAttrsError(diagnostic) &&
            isNoUnusedLabelWarningForReactiveStatement(diagnostic) &&
            isNoUsedBeforeAssigned(diagnostic, text, tsDoc));
    };
}
/**
 * Variable used before being assigned, can happen when  you do `export let x`
 * without assigning a value in strict mode. Should not throw an error here
 * but on the component-user-side ("you did not set a required prop").
 */
function isNoUsedBeforeAssigned(diagnostic, text, tsDoc) {
    if (diagnostic.code !== 2454) {
        return true;
    }
    return !tsDoc.hasProp(documents_1.getTextInRange(diagnostic.range, text));
}
/**
 * Unused label warning when using reactive statement (`$: a = ...`)
 */
function isNoUnusedLabelWarningForReactiveStatement(diagnostic) {
    return (diagnostic.code !== 7028 ||
        diagnostic.range.end.character - 1 !== diagnostic.range.start.character);
}
/**
 * Jsx cannot have multiple attributes with same name,
 * but that's allowed for svelte
 */
function isNoJsxCannotHaveMultipleAttrsError(diagnostic) {
    return diagnostic.code !== 17001;
}
/**
 * Some diagnostics have JSX-specific nomenclature. Enhance them for more clarity.
 */
function enhanceIfNecessary(diagnostic) {
    if (diagnostic.code === 2786) {
        return {
            ...diagnostic,
            message: `Type definitions are missing for this Svelte Component. ` +
                // eslint-disable-next-line max-len
                `It needs a class definition with at least the property '$$prop_def' which should contain a map of input property definitions.\n` +
                `Example:\n` +
                `class ComponentName { $$prop_def: { propertyName: string; } }\n\n` +
                diagnostic.message,
        };
    }
    return diagnostic;
}
//# sourceMappingURL=DiagnosticsProvider.js.map