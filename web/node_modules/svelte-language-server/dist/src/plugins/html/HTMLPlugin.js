"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLPlugin = void 0;
const vscode_emmet_helper_1 = require("vscode-emmet-helper");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const dataProvider_1 = require("./dataProvider");
class HTMLPlugin {
    constructor(docManager, configManager) {
        this.lang = vscode_html_languageservice_1.getLanguageService({ customDataProviders: [dataProvider_1.svelteHtmlDataProvider] });
        this.documents = new WeakMap();
        this.styleScriptTemplate = new Set(['template', 'style', 'script']);
        this.configManager = configManager;
        docManager.on('documentChange', (document) => {
            this.documents.set(document, document.html);
        });
    }
    doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        return this.lang.doHover(document, position, html);
    }
    getCompletions(document, position) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideMoustacheTag(html, document, position) ||
            documents_1.isInTag(position, document.scriptInfo) ||
            documents_1.isInTag(position, document.moduleScriptInfo)) {
            return null;
        }
        const emmetResults = {
            isIncomplete: true,
            items: [],
        };
        this.lang.setCompletionParticipants([
            vscode_emmet_helper_1.getEmmetCompletionParticipants(document, position, 'html', {}, emmetResults),
        ]);
        const results = this.isInComponentTag(html, document, position)
            ? // Only allow emmet inside component element tags.
                // Other attributes/events would be false positives.
                vscode_languageserver_1.CompletionList.create([])
            : this.lang.doComplete(document, position, html);
        return vscode_languageserver_1.CompletionList.create([...results.items, ...this.getLangCompletions(results.items), ...emmetResults.items], 
        // Emmet completions change on every keystroke, so they are never complete
        emmetResults.items.length > 0);
    }
    isInComponentTag(html, document, position) {
        return !!documents_1.getNodeIfIsInComponentStartTag(html, document.offsetAt(position));
    }
    getLangCompletions(completions) {
        const styleScriptTemplateCompletions = completions.filter((completion) => completion.kind === vscode_languageserver_1.CompletionItemKind.Property &&
            this.styleScriptTemplate.has(completion.label));
        const langCompletions = [];
        addLangCompletion('script', ['ts']);
        addLangCompletion('style', ['less', 'scss']);
        addLangCompletion('template', ['pug']);
        return langCompletions;
        function addLangCompletion(tag, languages) {
            const existingCompletion = styleScriptTemplateCompletions.find((completion) => completion.label === tag);
            if (!existingCompletion) {
                return;
            }
            languages.forEach((lang) => langCompletions.push({
                ...existingCompletion,
                label: `${tag} (lang="${lang}")`,
                insertText: existingCompletion.insertText &&
                    `${existingCompletion.insertText} lang="${lang}"`,
                textEdit: existingCompletion.textEdit && {
                    range: existingCompletion.textEdit.range,
                    newText: `${existingCompletion.textEdit.newText} lang="${lang}"`,
                },
            }));
        }
    }
    doTagComplete(document, position) {
        if (!this.featureEnabled('tagComplete')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideMoustacheTag(html, document, position)) {
            return null;
        }
        return this.lang.doTagComplete(document, position, html);
    }
    isInsideMoustacheTag(html, document, position) {
        const offset = document.offsetAt(position);
        const node = html.findNodeAt(offset);
        const charactersInNode = document.getText().substring(node.start, offset);
        return charactersInNode.lastIndexOf('{') > charactersInNode.lastIndexOf('}');
    }
    getDocumentSymbols(document) {
        if (!this.featureEnabled('documentSymbols')) {
            return [];
        }
        const html = this.documents.get(document);
        if (!html) {
            return [];
        }
        return this.lang.findDocumentSymbols(document, html);
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('html.enable') &&
            this.configManager.enabled(`html.${feature}.enable`));
    }
}
exports.HTMLPlugin = HTMLPlugin;
//# sourceMappingURL=HTMLPlugin.js.map