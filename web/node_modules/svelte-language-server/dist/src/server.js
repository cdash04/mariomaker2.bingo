"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startServer = void 0;
const lodash_1 = __importDefault(require("lodash"));
const vscode_languageserver_1 = require("vscode-languageserver");
const DiagnosticsManager_1 = require("./lib/DiagnosticsManager");
const documents_1 = require("./lib/documents");
const logger_1 = require("./logger");
const ls_config_1 = require("./ls-config");
const plugins_1 = require("./plugins");
const utils_1 = require("./utils");
var TagCloseRequest;
(function (TagCloseRequest) {
    TagCloseRequest.type = new vscode_languageserver_1.RequestType('html/tag');
})(TagCloseRequest || (TagCloseRequest = {}));
/**
 * Starts the language server.
 *
 * @param options Options to customize behavior
 */
function startServer(options) {
    let connection = options === null || options === void 0 ? void 0 : options.connection;
    if (!connection) {
        if (process.argv.includes('--stdio')) {
            console.log = (...args) => {
                console.warn(...args);
            };
            connection = vscode_languageserver_1.createConnection(process.stdin, process.stdout);
        }
        else {
            connection = vscode_languageserver_1.createConnection(new vscode_languageserver_1.IPCMessageReader(process), new vscode_languageserver_1.IPCMessageWriter(process));
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.logErrorsOnly) !== undefined) {
        logger_1.Logger.setLogErrorsOnly(options.logErrorsOnly);
    }
    const docManager = new documents_1.DocumentManager((textDocument) => new documents_1.Document(textDocument.uri, textDocument.text));
    const configManager = new ls_config_1.LSConfigManager();
    const pluginHost = new plugins_1.PluginHost(docManager, configManager);
    let sveltePlugin = undefined;
    connection.onInitialize((evt) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const workspaceUris = (_b = (_a = evt.workspaceFolders) === null || _a === void 0 ? void 0 : _a.map((folder) => folder.uri.toString())) !== null && _b !== void 0 ? _b : [
            (_c = evt.rootUri) !== null && _c !== void 0 ? _c : '',
        ];
        logger_1.Logger.log('Initialize language server at ', workspaceUris.join(', '));
        if (workspaceUris.length === 0) {
            logger_1.Logger.error('No workspace path set');
        }
        pluginHost.initialize(!!((_d = evt.initializationOptions) === null || _d === void 0 ? void 0 : _d.dontFilterIncompleteCompletions));
        pluginHost.updateConfig(((_e = evt.initializationOptions) === null || _e === void 0 ? void 0 : _e.config) || {});
        pluginHost.register((sveltePlugin = new plugins_1.SveltePlugin(configManager, (_f = evt.initializationOptions) === null || _f === void 0 ? void 0 : _f.prettierConfig)));
        pluginHost.register(new plugins_1.HTMLPlugin(docManager, configManager));
        pluginHost.register(new plugins_1.CSSPlugin(docManager, configManager));
        pluginHost.register(new plugins_1.TypeScriptPlugin(docManager, configManager, workspaceUris));
        const clientSupportApplyEditCommand = !!((_g = evt.capabilities.workspace) === null || _g === void 0 ? void 0 : _g.applyEdit);
        return {
            capabilities: {
                textDocumentSync: {
                    openClose: true,
                    change: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
                    save: {
                        includeText: false,
                    },
                },
                hoverProvider: true,
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: [
                        '.',
                        '"',
                        "'",
                        '`',
                        '/',
                        '@',
                        '<',
                        // Emmet
                        '>',
                        '*',
                        '#',
                        '$',
                        '+',
                        '^',
                        '(',
                        '[',
                        '@',
                        '-',
                        // No whitespace because
                        // it makes for weird/too many completions
                        // of other completion providers
                        // Svelte
                        ':',
                    ],
                },
                documentFormattingProvider: true,
                colorProvider: true,
                documentSymbolProvider: true,
                definitionProvider: true,
                codeActionProvider: ((_j = (_h = evt.capabilities.textDocument) === null || _h === void 0 ? void 0 : _h.codeAction) === null || _j === void 0 ? void 0 : _j.codeActionLiteralSupport) ? {
                    codeActionKinds: [
                        vscode_languageserver_1.CodeActionKind.QuickFix,
                        vscode_languageserver_1.CodeActionKind.SourceOrganizeImports,
                        ...(clientSupportApplyEditCommand ? [vscode_languageserver_1.CodeActionKind.Refactor] : []),
                    ],
                }
                    : true,
                executeCommandProvider: clientSupportApplyEditCommand
                    ? {
                        commands: [
                            'function_scope_0',
                            'function_scope_1',
                            'function_scope_2',
                            'function_scope_3',
                            'constant_scope_0',
                            'constant_scope_1',
                            'constant_scope_2',
                            'constant_scope_3',
                            'extract_to_svelte_component',
                        ],
                    }
                    : undefined,
                renameProvider: ((_l = (_k = evt.capabilities.textDocument) === null || _k === void 0 ? void 0 : _k.rename) === null || _l === void 0 ? void 0 : _l.prepareSupport) ? { prepareProvider: true }
                    : true,
                referencesProvider: true,
            },
        };
    });
    connection.onRenameRequest((req) => pluginHost.rename(req.textDocument, req.position, req.newName));
    connection.onPrepareRename((req) => pluginHost.prepareRename(req.textDocument, req.position));
    connection.onDidChangeConfiguration(({ settings }) => {
        var _a;
        pluginHost.updateConfig((_a = settings.svelte) === null || _a === void 0 ? void 0 : _a.plugin);
    });
    connection.onDidOpenTextDocument((evt) => {
        docManager.openDocument(evt.textDocument);
        docManager.markAsOpenedInClient(evt.textDocument.uri);
    });
    connection.onDidCloseTextDocument((evt) => docManager.closeDocument(evt.textDocument.uri));
    connection.onDidChangeTextDocument((evt) => docManager.updateDocument(evt.textDocument, evt.contentChanges));
    connection.onHover((evt) => pluginHost.doHover(evt.textDocument, evt.position));
    connection.onCompletion((evt) => pluginHost.getCompletions(evt.textDocument, evt.position, evt.context));
    connection.onDocumentFormatting((evt) => pluginHost.formatDocument(evt.textDocument, evt.options));
    connection.onRequest(TagCloseRequest.type, (evt) => pluginHost.doTagComplete(evt.textDocument, evt.position));
    connection.onDocumentColor((evt) => pluginHost.getDocumentColors(evt.textDocument));
    connection.onColorPresentation((evt) => pluginHost.getColorPresentations(evt.textDocument, evt.range, evt.color));
    connection.onDocumentSymbol((evt) => pluginHost.getDocumentSymbols(evt.textDocument));
    connection.onDefinition((evt) => pluginHost.getDefinitions(evt.textDocument, evt.position));
    connection.onReferences((evt) => pluginHost.findReferences(evt.textDocument, evt.position, evt.context));
    connection.onCodeAction((evt) => pluginHost.getCodeActions(evt.textDocument, evt.range, evt.context));
    connection.onExecuteCommand(async (evt) => {
        var _a;
        const result = await pluginHost.executeCommand({ uri: (_a = evt.arguments) === null || _a === void 0 ? void 0 : _a[0] }, evt.command, evt.arguments);
        if (vscode_languageserver_1.WorkspaceEdit.is(result)) {
            const edit = { edit: result };
            connection === null || connection === void 0 ? void 0 : connection.sendRequest(vscode_languageserver_1.ApplyWorkspaceEditRequest.type.method, edit);
        }
        else if (result) {
            connection === null || connection === void 0 ? void 0 : connection.sendNotification(vscode_languageserver_1.ShowMessageNotification.type.method, {
                message: result,
                type: vscode_languageserver_1.MessageType.Error,
            });
        }
    });
    connection.onCompletionResolve((completionItem) => {
        const data = completionItem.data;
        if (!data) {
            return completionItem;
        }
        return pluginHost.resolveCompletion(data, completionItem);
    });
    const diagnosticsManager = new DiagnosticsManager_1.DiagnosticsManager(connection.sendDiagnostics, docManager, pluginHost.getDiagnostics.bind(pluginHost));
    connection.onDidChangeWatchedFiles((para) => {
        for (const change of para.changes) {
            const filename = utils_1.urlToPath(change.uri);
            if (filename) {
                pluginHost.onWatchFileChanges(filename, change.type);
            }
        }
        diagnosticsManager.updateAll();
    });
    connection.onDidSaveTextDocument(() => diagnosticsManager.updateAll());
    docManager.on('documentChange', lodash_1.default.debounce(async (document) => diagnosticsManager.update(document), 500));
    docManager.on('documentClose', (document) => diagnosticsManager.removeDiagnostics(document));
    // The language server protocol does not have a specific "did rename/move files" event,
    // so we create our own in the extension client and handle it here
    connection.onRequest('$/getEditsForFileRename', async (fileRename) => pluginHost.updateImports(fileRename));
    connection.onRequest('$/getCompiledCode', async (uri) => {
        const doc = docManager.get(uri);
        if (!doc)
            return null;
        if (doc) {
            const compiled = await sveltePlugin.getCompiledResult(doc);
            if (compiled) {
                const js = compiled.js;
                const css = compiled.css;
                return { js, css };
            }
            else {
                return null;
            }
        }
    });
    connection.listen();
}
exports.startServer = startServer;
//# sourceMappingURL=server.js.map